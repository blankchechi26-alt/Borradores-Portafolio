# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cn1ZFTxXnVTVFMPaEH7ao5FuZEvTmRpH
"""

# app.py
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
from scipy.optimize import minimize
from io import BytesIO

st.set_page_config(page_title="ProTrader – Portafolio Profesional", layout="wide")

# ------------------------
# Simple auth (password)
# ------------------------
PASSWORD = st.secrets.get("APP_PASSWORD", "demo123") if "APP_PASSWORD" in st.secrets else "demo123"
pw = st.sidebar.text_input("Password", type="password")
if pw != PASSWORD:
    st.sidebar.error("Password incorrecto")
    st.stop()

# ------------------------
# UI styles (sobrio)
# ------------------------
st.markdown("""
<style>
section.main { background-color: #0f1720; color: #e6eef6; }
.streamlit-expanderHeader { color: #e6eef6; }
div.block-container { padding-top: 1rem; }
</style>
""", unsafe_allow_html=True)

# ------------------------
# Helpers
# ------------------------
def descargar_data(tickers, start, end, interval):
    df = yf.download(tickers, start=start, end=end, interval=interval)["Adj Close"]
    if isinstance(df, pd.Series):
        df = df.to_frame()
    df = df.dropna(how="all", axis=1)
    return df

def retornos_log(data):
    return np.log(data / data.shift(1)).dropna()

def port_stats(weights, rets, periods_per_year=252):
    port_ret = rets.dot(weights)
    ann_ret = port_ret.mean() * periods_per_year
    ann_vol = port_ret.std() * np.sqrt(periods_per_year)
    sharpe = ann_ret / ann_vol if ann_vol != 0 else 0
    return ann_ret, ann_vol, sharpe

def negative_sharpe(weights, rets):
    _, vol, sharpe = port_stats(weights, rets)
    return -sharpe

def optimize_sharpe(rets):
    n = rets.shape[1]
    x0 = np.repeat(1/n, n)
    bounds = tuple((0,1) for _ in range(n))
    cons = ({'type':'eq', 'fun': lambda x: np.sum(x) - 1})
    res = minimize(negative_sharpe, x0=x0, args=(rets,), bounds=bounds, constraints=cons)
    return res.x if res.success else x0

def to_excel_bytes(df_dict):
    out = BytesIO()
    with pd.ExcelWriter(out, engine="openpyxl") as writer:
        for name, df in df_dict.items():
            df.to_excel(writer, sheet_name=name[:31])
    return out.getvalue()

# ------------------------
# Sidebar inputs
# ------------------------
st.sidebar.title("Parámetros")
tickers = st.sidebar.text_area("Tickers (coma separados)", value="AAPL,MSFT,AMZN,GOOGL,META,TSLA,NVDA")
tickers = [t.strip().upper() for t in tickers.split(",") if t.strip()]
start = st.sidebar.date_input("Fecha inicio", pd.to_datetime("2020-01-01"))
end = st.sidebar.date_input("Fecha fin", pd.to_datetime("2024-12-31"))
freq_map = {"Diaria":"1d", "Semanal":"1wk", "Mensual":"1mo"}
freq_choice = st.sidebar.selectbox("Frecuencia", list(freq_map.keys()), index=0)
interval = freq_map[freq_choice]
initial_capital = st.sidebar.number_input("Capital inicial (USD)", value=100_000, step=1000)
include_benchmark = st.sidebar.checkbox("Incluir benchmark (S&P 500 ^GSPC)", value=True)

if include_benchmark:
    benchmark = "^GSPC"
else:
    benchmark = None

run = st.sidebar.button("Correr análisis")

# ------------------------
# Main
# ------------------------
st.title("ProTrader — Análisis Profesional de Portafolios")

if not tickers:
    st.info("Ingresa al menos un ticker en la barra lateral")
    st.stop()

if run:
    st.subheader("Descargando datos")
    tickers_all = tickers + ([benchmark] if benchmark else [])
    data = descargar_data(tickers_all, start, end, interval)
    if data.empty:
        st.error("No se obtuvieron datos. Revisa tickers o rango de fechas.")
        st.stop()

    if benchmark and benchmark in data.columns:
        bench_series = data[benchmark]
        data = data.drop(columns=[benchmark])

    st.write(f"Activos obtenidos: {', '.join(data.columns)}")
    st.line_chart(data)

    st.subheader("Retornos (log) y estadísticas")
    rets = retornos_log(data)
    st.dataframe(rets.describe().T[["mean","std","min","max"]])

    # Correlaciones
    st.subheader("Matriz de correlación")
    st.dataframe(rets.corr())

    # Optimización Sharpe
    st.subheader("Optimización: máxima Sharpe (long-only)")
    weights_opt = optimize_sharpe(rets)
    df_weights = pd.DataFrame({"Ticker": data.columns, "Peso_opt": weights_opt.round(4)})
    st.table(df_weights.set_index("Ticker"))

    # Métricas portafolio optimizado
    ann_ret, ann_vol, sharpe = port_stats(weights_opt, rets)
    c1, c2, c3 = st.columns(3)
    c1.metric("Retorno anualizado (opt)", f"{ann_ret:.2%}")
    c2.metric("Volatilidad anualizada (opt)", f"{ann_vol:.2%}")
    c3.metric("Sharpe (opt)", f"{sharpe:.2f}")

    # Evolución del portafolio
    st.subheader("Evolución del valor (portafolio optimizado)")
    port_ret = rets.dot(weights_opt)
    cum = np.exp(port_ret.cumsum())  # porque usamos log returns
    value = initial_capital * cum
    st.line_chart(value)

    # Comparación contra benchmark si existe
    if benchmark and benchmark in locals().get("bench_series", {}):
        st.subheader("Comparación vs Benchmark")
        bench_rets = retornos_log(bench_series.to_frame(benchmark)).iloc[:,0]
        # align lengths
        common_index = rets.index.intersection(bench_rets.index)
        port_cum = np.exp(rets.loc[common_index].dot(weights_opt).cumsum())
        bench_cum = np.exp(bench_rets.loc[common_index].cumsum())
        df_cmp = pd.DataFrame({
            "Portafolio": port_cum * initial_capital,
            "Benchmark": bench_cum * initial_capital
        }, index=common_index)
        st.line_chart(df_cmp)

    # Histograma y rolling vol
    st.subheader("Distribución de retornos y volatilidad rolling")
    st.bar_chart(port_ret.hist(bins=30, figsize=(6,2)).get_figure()) if False else None  # placeholder to avoid matplotlib dependency in UI
    st.write("Volatilidad rolling (30 días equivalente)")
    rolling_vol = port_ret.rolling(window=30).std() * np.sqrt(252)
    st.line_chart(rolling_vol.dropna())

    # Exportar resultados
    st.subheader("Exportar")
    to_save = {
        "Precios": data,
        "Retornos": rets,
        "Pesos_Opt": df_weights,
        "Valor_Portafolio": value
    }
    xlsx_bytes = to_excel_bytes(to_save)
    st.download_button("Descargar reporte (Excel)", xlsx_bytes, "reporte_portafolio.xlsx")
    st.success("Análisis completado.")